"use strict";var X=Object.create;var v=Object.defineProperty;var Z=Object.getOwnPropertyDescriptor;var ee=Object.getOwnPropertyNames;var te=Object.getPrototypeOf,ne=Object.prototype.hasOwnProperty;var D=(r,e)=>{for(var t in e)v(r,t,{get:e[t],enumerable:!0})},N=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of ee(e))!ne.call(r,i)&&i!==t&&v(r,i,{get:()=>e[i],enumerable:!(n=Z(e,i))||n.enumerable});return r};var M=(r,e,t)=>(t=r!=null?X(te(r)):{},N(e||!r||!r.__esModule?v(t,"default",{value:r,enumerable:!0}):t,r)),re=r=>N(v({},"__esModule",{value:!0}),r);var Ee={};D(Ee,{AmqpSdk:()=>C,EventsWorker:()=>d,VHOST:()=>f,amqpSdk:()=>F,eventsWorker:()=>y,executionDataHelper:()=>R,flowConsumer:()=>O,flowHelpers:()=>A,flowInterpreter:()=>Q,rpcRequest:()=>I});module.exports=re(Ee);var H=require("amqp-connection-manager");var $=require("uuid"),x=class{constructor(e={}){this.config={retryDelay:e.retryDelay??(process.env.SEQ_QUEUE_RETRY_DELAY?Number(process.env.SEQ_QUEUE_RETRY_DELAY):100),retryAttempts:e.retryAttempts??(process.env.SEQ_QUEUE_RETRY_ATTEMPTS?Number(process.env.SEQ_QUEUE_RETRY_ATTEMPTS):5)},this.callbacks={},this.results={},this.items=[],this.running=!1}deleteCurrentItem(){let e=this.items.shift();e&&(delete this.callbacks[e],delete this.results[e])}async runWithRetries(e){let t=this.items[0];try{let n=await this.callbacks[t]();this.results[t].resolve(n),this.deleteCurrentItem(),this.run().catch(i=>{console.error("Error during scheduling callback",i)})}catch(n){e<this.config.retryAttempts?(console.error(`Error during executing queue task (attempt: ${e})`,n),await new Promise(i=>setTimeout(i,this.config.retryDelay)),this.runWithRetries(e+1).catch(i=>{console.error("Error during scheduling callback",i)})):(console.error("Reached maximum queue retry attempts",n),this.results[t].reject(n),this.deleteCurrentItem(),this.run().catch(i=>{console.error("Error during scheduling callback",i)}))}}async run(){this.running=!0,this.items.length>0?await this.runWithRetries(1):this.running=!1}add(e){let t=(0,$.v4)();return this.callbacks[t]=e,this.items.push(t),this.running||this.run().catch(n=>{console.error("Error during scheduling callback",n)}),new Promise((n,i)=>this.results[t]={resolve:n,reject:i})}};var f=(n=>(n.RESULTS="results",n.ACTIONS="actions",n.EVENTS="events",n))(f||{});var ie=process.env.AMQP_CONNECTION_TIMEOUT||6e4,C=class{constructor(){this.connection={};this.channel={};this.consumerTag={["actions"]:{},["results"]:{},["events"]:{}};this.opts={};this.queues={["actions"]:[],["results"]:[],["events"]:[]};this.existingConsumers={["actions"]:{},["results"]:{},["events"]:{}};this.seqQueue=new x}getAmqpUri(e){switch(e){case"actions":return process.env.AMQP_URI_ACTIONS;case"events":return process.env.AMQP_URI_EVENTS;case"results":return process.env.AMQP_URI_RESULTS}}checkConnection(e){if(!this.channel[e])throw new Error("Connection not created")}async checkIfQueueExists(e,t){return this.channel[t].checkQueue(e)}async connectToAMQP(e){console.info(`Establishing connection to vhost ${e}`);let t=(0,H.connect)(this.getAmqpUri(e),{connectionOptions:this.opts.connectionOptions});if(t)try{await Promise.race([new Promise((n,i)=>setTimeout(()=>i(),Number(ie))),new Promise(n=>{t.addListener("connect",()=>{console.info(`Rabbit successfully connected to vhost: "${e}"`),n()}),t.addListener("connectFailed",()=>{console.info(`Rabbit failed to connect to vhost: "${e}"`),process.exit(-2)}),t.addListener("disconnect",()=>{console.warn(`Rabbit disconnected from vhost: "${e}"`)}),t.addListener("blocked",()=>{console.warn(`Rabbit connection blocked on vhost: "${e}"`)}),t.addListener("unblocked",()=>{console.info(`Rabbit connection unblocked on vhost: "${e}"`)})})]),this.connection[e]=t}catch{console.error(`Rabbit connection timeout. Could not connect to vhost ${e}. Check connection details`),process.exit(-2)}else console.error(`Connection to vhost ${e} was not created!`),process.exit(-3);return t}async amqpConnect(e,t){let n=await this.connectToAMQP(e);if(n)return new Promise((i,o)=>{let s=n.createChannel({json:!0,setup:async a=>{if(a){this.channel[e]=a,t&&await t();for(let u in this.existingConsumers[e])this.existingConsumers[e][u].queueOptions?.exclusive&&await this.assertQueue(this.existingConsumers[e][u].queue,e,this.existingConsumers[e][u].queueOptions),await this.consume(this.existingConsumers[e][u]);for(let u of this.queues[e])this.publish(u);this.queues[e]=[],i(n)}o()}});s.addListener("connect",()=>{console.info(`Rabbit successfully connected to channel for vhost: "${e}"`)}),s.addListener("error",()=>{console.error(`Rabbit failed to connect to channel for vhost: "${e}"`)}),s.addListener("close",()=>{console.warn(`Rabbit connection to vhost: "${e}" channel has closed!"`)})});throw new Error("Could not connect to AMQP queue!")}async connectAndInit(e,t){(await this.amqpConnect(e,t)).on("close",()=>{console.error(`Lost AMQP connection with vhost: "${e}". Trying to reconnect in a while.`)})}async connectToVHosts(e){for(let t of e)await this.connectAndInit(t)}async configure(e,t=["events","results","actions"]){this.opts={...e},await this.connectToVHosts(t)}async unsubscribe(e,t,n){if(this.checkConnection(e),!this.consumerTag[e][t]){if(n)return;throw new Error("Cannot unsubscribe from queue with undefined consumer")}await this.channel[e].cancel(this.consumerTag[e][t].consumerTag),delete this.existingConsumers[e][t],delete this.consumerTag[e][t]}publish({exchange:e,routingKey:t,vhost:n,data:i,opts:o={}}){this.checkConnection(n);try{return this.channel[n].publish(e,t,i,o)}catch(s){throw console.error(`Could not send message. Origin error: ${s.message}. Retrying when reconnected.`),this.queues[n].push({exchange:e,routingKey:t,vhost:n,data:i,opts:o}),s}}async consume({vhost:e,queue:t,prefetchValue:n=0,ack:i=!1,explicitAck:o=!1,queueOptions:s={},callback:a}){this.checkConnection(e),this.existingConsumers[e][t]={vhost:e,queue:t,prefetchValue:n,ack:i,explicitAck:o,queueOptions:s,callback:a};let u=async l=>{if(l===null)throw new Error("Received null message, channel closed. Trying to reconnect");let p;try{p=JSON.parse(l.content.toString())}catch{throw new Error("Incorrect incoming AMQP data")}o?await a(p,{ack:()=>this.channel[e].ack(l)}):(await a(p,{}),i&&this.channel[e].ack(l))};if(!await this.checkIfQueueExists(t,e))throw new Error("Queue does not exist!");await this.seqQueue.add(async()=>{await this.channel[e].prefetch(n),this.consumerTag[e][t]=await this.channel[e].consume(t,l=>{u(l).catch(p=>{console.error(`Error during processing message on queue ${t}.`,p)})},{noAck:!i}),await this.channel[e].prefetch(0)})}async assertQueue(e,t,n){return this.checkConnection(t),(await this.channel[t].assertQueue(e,n)).queue}async deleteQueue(e,t){this.checkConnection(t),await this.channel[t].deleteQueue(e)}async assertExchange(e,t,n,i){this.checkConnection(n),await this.channel[n].assertExchange(e,t,i)}async bindQueue(e,t,n,i){this.checkConnection(n),await this.channel[n].bindQueue(e,t,i??"")}},F=new C;var U=M(require("os")),K=require("uuid"),d=class{constructor(){this.amqp=F}static parseQueue(e,t){let n=e;for(let[i,o]of Object.entries(t))n=n.replace(`{${i}}`,o);return n}async init(e,t){await this.amqp.configure(e,t)}async consume({vhost:e="events",queue:t,queueParams:n={},prefetchValue:i=0,ack:o=!1,explicitAck:s=!1,callback:a,queueOptions:u={}}){this.logging(`Asserting ${t} on vhost ${e} with params: $`,[n]);let c=d.parseQueue(t,n);await this.amqp.assertQueue(c,e,u),this.logging(`Consuming ${t} with prefetch: ${i}, ack: ${o}`),await this.amqp.consume({vhost:e,queue:c,prefetchValue:i,ack:o,explicitAck:s,queueOptions:u,callback:this.consumerCallback(a)})}async consumeBroadcast({vhost:e="events",exchange:t,callback:n}){let i={exclusive:!0};this.logging(`Asserting ${t} exchange on vhost ${e}`),await this.amqp.assertExchange(t,"fanout",e);let o=await this.amqp.assertQueue(`broadcast/${t}/${(0,K.v4)()}`,e,i);await this.amqp.bindQueue(o,t,e),this.logging(`Consuming ${t} exchange`),await this.amqp.consume({vhost:e,queue:o,queueOptions:i,callback:this.consumerCallback(n)})}async publish({queue:e,queueParams:t={},event:n,vhost:i="events",opts:o={},queueOptions:s={}}){this.logging(`Publishing on queue ${e}, params $ with event $ and opts $`,[t,n,o]);let a=Buffer.from(JSON.stringify(n)),u=d.parseQueue(e,t);await this.amqp.assertQueue(u,i,s),this.amqp.publish({vhost:i,exchange:"",routingKey:u,data:a,opts:o})}async broadcast({exchange:e,event:t,vhost:n="events",opts:i={}}){this.logging(`Broadcasting to exchange ${e} with event $ and opts $`,[t,i]);let o=Buffer.from(JSON.stringify(t));await this.amqp.assertExchange(e,"fanout",n),this.amqp.publish({vhost:n,exchange:e,routingKey:"",data:o,opts:i})}async unsubscribe({queue:e,queueParams:t={},vhost:n="events",allowNotSubscribed:i=!1}){this.logging(`Unsubscribing from queue ${e} with params $`,[t]);let o=d.parseQueue(e,t);await this.amqp.unsubscribe(n,o,i)}async deleteQueue({queue:e,queueParams:t={},vhost:n="events"}){this.logging(`Deleting queue ${e} with params $`,[t]);let i=d.parseQueue(e,t);await this.amqp.deleteQueue(i,n)}async registerConsumer({queue:e,consumer:t,vhost:n="events",prefetchValue:i=0,ack:o=!1}){await this.consume({queue:e,vhost:n,prefetchValue:i,ack:o,callback:async s=>{let a=await t(s);for(let u of a)await this.publish(u)}})}logging(e,t){if(process.env.LOGGING_VERBOSE==="true"){let n=0,i=t?e.replace(/\$/g,()=>JSON.stringify(t[n++],null,2)):e;console.debug(`${U.default.hostname()}: ${i}`)}}consumerCallback(e){return process.env.LOGGING_VERBOSE==="true"?(t,n)=>(this.logging("Consumer debug: $",[t]),e?e(t,n):()=>Promise.resolve()):e||(()=>Promise.resolve())}},y=new d;var E=M(require("lodash/get"));var A={};D(A,{applyInputMapping:()=>w,composition:()=>pe,condition:()=>ue,flowTemplate:()=>q,parallel:()=>le,param:()=>ae,queue:()=>V});var S=M(require("lodash/get"));function L(r){return r.type==="event"}function _(r){return r.type==="param"}function oe(r){return Array.isArray(r)}function se(r){return r.type==="condition"}function B(r){return r.type==="composition"}function T(r,e,t){if(r.length===0)return t;let[n,...i]=r,o=T(i,e,t);if(B(n))return T(n.restFlow,e,o);if(se(n)){let{queue:s,predicate:a,elseFlow:u,thenFlow:c}=n;return[{vhost:s.vhost,queue:s.queue,errorQueue:s.errorQueue,inputMapping:s.inputMapping,outputMapping:s.outputMapping,errorMapping:s.errorMapping,queueParams:s.queueParams,predicate:a,nextFlow:T(c,e,o),elseFlow:T(u??[],e,o),queueOptions:s.queueOptions}]}if(L(n)){let{queue:s,vhost:a,errorQueue:u,inputMapping:c,outputMapping:l,errorMapping:p,queueParams:g,queueOptions:m}=n;return[{queue:s,vhost:a,inputMapping:c,outputMapping:l,errorMapping:p,nextFlow:o,errorQueue:u,queueParams:g,queueOptions:m}]}if(_(n)){let s=e[n.name];return typeof s=="string"?[{queue:s,inputMapping:{},outputMapping:{},errorMapping:{},nextFlow:o}]:[{queue:s.queue,vhost:s.vhost,inputMapping:s.inputMapping,outputMapping:s.outputMapping,errorMapping:s.errorMapping,errorQueue:s.errorQueue,queueParams:s.queueParams,nextFlow:o}]}if(oe(n)){let s=T(i,e,t);return n.map(a=>T(a,e,s)).reduce((a,u)=>u?a.concat(u):a,[])}}function w(r,e={}){return Object.keys(e).reduce((t,n)=>{let i=e[n];return Array.isArray(i)?{...t,[n]:i.map(o=>(0,S.default)(r,o))}:{...t,[n]:(0,S.default)(r,i)}},{})}function q(r,...e){let t=r,n=e;B(r)&&(t=r.restFlow[0],n=[...r.restFlow.slice(1),...n]);let i=o=>({vhost:t.vhost,initQueue:t.queue,inputData:w(o.flowVariables,t.inputMapping),flowVariables:o.flowVariables,errorVariables:o.errorVariables,outputMapping:t.outputMapping,errorMapping:t.errorMapping,nextFlow:T(n,o.params),errorQueue:t.errorQueue,queueOptions:t.queueOptions});return i.restFlow=[r,...e],i}function V(r,e){return{type:"event",queue:r,vhost:e.vhost,inputMapping:e.inputMapping,outputMapping:e.outputMapping,errorMapping:e.errorMapping,queueParams:e.queueParams,queueOptions:e.queueOptions,onError(t){return{...this,errorQueue:t}}}}function ae(r){return{type:"param",name:r}}function ue(r){return{type:"condition",...r}}function pe(r,...e){let t=r?.restFlow??[];for(let n of e)t=[...t,...n.restFlow];return{type:"composition",restFlow:t}}function le(...r){function e(i){return Array.isArray(i)&&(L(i[0])||_(i[0]))}function t(i){return Array.isArray(i)&&!e(i)}return r.reduce((i,o)=>e(o)?i.concat([o]):t(o)?i.concat([o]):i.concat([[o]]),[])}var h=require("lodash"),ce={passFlowVariables:!1,passErrorVariables:!0};function G(r,e,t){return e?Object.keys(e).reduce((n,i)=>{let o=e[i];if(me(o)){let s=o["$push"],a=n[s]??[];return a instanceof Array?{...n,[s]:[...a,(0,E.default)(t,i)]}:{...n}}else if(ge(o)){let s=o["$remove"],a=n[s]??[];return a instanceof Array?{...n,[s]:a.filter(u=>!(0,h.isEqual)(u,(0,E.default)(t,i)))}:{...n}}else{if(k(o))return{...n};if(Array.isArray(o)){let s=o.reduce((a,u)=>({...a,[u]:(0,E.default)(t,i)}),{});return{...n,...s}}return{...n,[o]:(0,E.default)(t,i)}}},r):r}function k(r){return(0,h.isObject)(r)&&!(r instanceof Array)}function me(r){return k(r)&&!!r["$push"]}function ge(r){return k(r)&&!!r["$remove"]}function W(r,e,t){return(r??[]).map(n=>{let i={inputData:w(e,n.inputMapping??{}),outputMapping:n.outputMapping,errorMapping:n.errorMapping,nextFlow:n.nextFlow,errorQueue:n.errorQueue,elseFlow:n.elseFlow,predicate:n.predicate,flowVariables:e,errorVariables:t};return{vhost:n.vhost,queue:n.queue,queueParams:w(e,n.queueParams??{}),event:i,queueOptions:n.queueOptions}})}async function Q(r,e,t,n){try{let i=t.inputData,o=await Promise.resolve(e(i,{ack:n,publish:de(t)}))??{},s=G(t.flowVariables??{},t.outputMapping,o),a=G(t.errorVariables??{},t.errorMapping,o);return t.predicate&&!(0,E.default)(s,t.predicate)?W(t.elseFlow??[],s,a):W(t.nextFlow??[],s,a)}catch(i){return console.error(`Error in consumer "${r}"`),console.error(i),[{queue:t.errorQueue??"Error/General",event:{inputData:{queue:r,error:{message:i?.message,stack:i?.stack,data:i.data},event:t}}}]}}function de(r){return async({event:e,options:t=ce,queueParams:n,vhost:i})=>{t?.passErrorVariables&&(e.errorVariables=(0,h.isObject)(e.errorVariables)?Object.assign(r.errorVariables??{},e.errorVariables):r.errorVariables??{}),t?.passFlowVariables&&(e.flowVariables=(0,h.isObject)(e.flowVariables)?Object.assign(r.flowVariables??{},e.flowVariables):r.flowVariables??{}),await y.publish({vhost:i,queue:e.initQueue,queueParams:n??{},event:e})}}async function O({queue:r,queueParams:e,prefetchValue:t=0,explicitAck:n=!1,vhost:i,callback:o,queueOptions:s}){await y.consume({queue:r,queueParams:e,prefetchValue:t,ack:!0,vhost:i,explicitAck:n,queueOptions:s,callback:async(a,u)=>{console.info(`Consuming queue ${r}`);let c=await Q(r,o,a,u?.ack);for(let l of c)await y.publish(l)}})}var R={};D(R,{createActionExecutionData:()=>Te,createCodeContext:()=>Y});var j=r=>({startTime:r.startTime,finishTime:r.finishTime,status:r.status,result:r?.twiddlebugResult?.result,errorCode:r?.twiddlebugResult?.errorCode,output:`${r?.twiddlebugResult?.result?JSON.stringify(r.twiddlebugResult.result)+`
`:""}${r?.twiddlebugResult?.stdout?r.twiddlebugResult.stdout+`
`:""}${r?.twiddlebugResult?.stderr?r.twiddlebugResult.stderr+`
`:""}`}),ye=(r,e)=>({usedPlugin:r.usedPlugin,pluginAuthId:e.auth?.authId,method:r.method,params:r.params?.reduce((t,n)=>({...t,[n.name]:{...n,resolved:!(n.code||n.type==="vault")}}),{}),pluginSettings:r.pluginSettings?.reduce((t,n)=>({...t,[n.name]:{...n,resolved:n.type!=="vault"}}),{}),pluginAccount:r.pluginAccount}),Y=({actions:r,actionResults:e=[],pipelineExecutionId:t,pipelineRevision:n,trigger:i,triggerPayload:o,configuration:s,inputs:a,configurations:u})=>{let c=r.reduce((l,p)=>{let g=e.filter(b=>b.actionId===p.uuid).pop(),m=g?j(g):{};return{[p.codeId]:{id:p.codeId,name:p.name,mandatory:p.mandatory,retries:p.retries,timeout:p.timeout,plugin:p.usedPlugin&&{name:p.usedPlugin.name,version:p.usedPlugin.version},...m,executions:e.filter(b=>b.actionId===p.uuid).map(j)},...l}},{});return{kaholo:{actions:c,pipeline:{id:n?.pipeline.id,name:n?.pipeline.name,configurations:u},execution:{id:t,inputs:a,agent:{name:n?.agent?.name,attributes:n?.agent?.attributes},trigger:{message:i,payload:o},configuration:s}},actions:c}},Te=({actionExecutionId:r,pipelineExecutionId:e,actionId:t,pipelineId:n,agentKey:i,plugin:o,pipelineRevision:s,actionRevision:a,actionResults:u,trigger:c,triggerPayload:l,configuration:p,inputs:g,configurations:m})=>({actionExecutionId:r,pipelineExecutionId:e,actionId:t,pipelineId:n,type:a.type,agentKey:i,condition:a.condition,preHook:a.preHook,postHook:a.postHook,retries:a.retries??0,timeout:a.timeout,pipelineRevision:s,codeContext:Y({actions:s.actions,actionResults:u,pipelineExecutionId:e,pipelineRevision:s,trigger:c,triggerPayload:l,configuration:p,inputs:g,configurations:m}),...a.usedPlugin?ye(a,o):{}});var z=require("uuid");var J=parseInt(process.env.RPC_REQUEST_TIMEOUT)||2e4,P=class extends Error{constructor({message:t,data:n}){super(t);Error.captureStackTrace&&Error.captureStackTrace(this,P),this.data=n,this.error=n.responseData?.error}};async function fe(r,e){await y.unsubscribe({vhost:r,queue:"RPC/Response/{requestId}",queueParams:{requestId:e}}),await y.deleteQueue({vhost:r,queue:"RPC/Response/{requestId}",queueParams:{requestId:e}})}async function I({requestVhost:r="events",responseVhost:e="events",requestQueue:t,queueParams:n,requestData:i,retries:o=0}){let s=(0,z.v4)(),a={expires:J,durable:!1},c=q(V(t,{vhost:r,inputMapping:{requestId:"requestId",requestData:"requestData"},outputMapping:{ok:"ok",responseData:"responseData"}}),V("RPC/Response/{requestId}",{vhost:e,queueParams:{requestId:"requestId"},inputMapping:{ok:"ok",responseData:"responseData"},queueOptions:a}))({flowVariables:{requestData:i,requestId:s},params:{}});return await y.publish({vhost:r,queue:t,queueParams:n,event:c}),new Promise((l,p)=>{let g=setTimeout(()=>{o?(console.info(`Retrying RPC request because of timeout (${o-1} left)} ${t}`),I({requestVhost:r,responseVhost:e,requestQueue:t,queueParams:n,requestData:i,retries:o-1}).then(l).catch(p)):p(new Error(`Timeout reached waiting for RPC response for ${t} request`))},J);O({vhost:e,queue:"RPC/Response/{requestId}",queueParams:{requestId:s},queueOptions:a,callback:m=>(clearTimeout(g),setTimeout(()=>{fe(e,s).catch(b=>console.error("Error during RPC cleanup",b))},1e3),m.ok?l(m.responseData):o?(console.info(`Retrying RPC request because of error (${o-1} left) "${t}"`,m.responseData?.error),I({requestVhost:r,responseVhost:e,requestQueue:t,queueParams:n,requestData:i,retries:o-1}).then(l).catch(p)):p(new P({message:`Error in RPC response for ${t} request`,data:m})),{})}).catch(m=>{p(m),console.error("Error during RPC response consumer registration",m)})})}0&&(module.exports={AmqpSdk,EventsWorker,VHOST,amqpSdk,eventsWorker,executionDataHelper,flowConsumer,flowHelpers,flowInterpreter,rpcRequest});
