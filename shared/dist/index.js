"use strict";var G=Object.create;var v=Object.defineProperty;var z=Object.getOwnPropertyDescriptor;var X=Object.getOwnPropertyNames;var Z=Object.getPrototypeOf,ee=Object.prototype.hasOwnProperty;var D=(r,e)=>{for(var t in e)v(r,t,{get:e[t],enumerable:!0})},I=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of X(e))!ee.call(r,o)&&o!==t&&v(r,o,{get:()=>e[o],enumerable:!(n=z(e,o))||n.enumerable});return r};var N=(r,e,t)=>(t=r!=null?G(Z(r)):{},I(e||!r||!r.__esModule?v(t,"default",{value:r,enumerable:!0}):t,r)),te=r=>I(v({},"__esModule",{value:!0}),r);var ye={};D(ye,{AmqpSdk:()=>C,EventsWorker:()=>T,VHOST:()=>E,amqpSdk:()=>F,eventsWorker:()=>y,executionDataHelper:()=>Q,flowConsumer:()=>V,flowHelpers:()=>S,flowInterpreter:()=>k,rpcRequest:()=>R});module.exports=te(ye);var U=require("amqp-connection-manager");var H=require("uuid"),x=class{constructor(e={}){this.config={retryDelay:e.retryDelay??(process.env.SEQ_QUEUE_RETRY_DELAY?Number(process.env.SEQ_QUEUE_RETRY_DELAY):100),retryAttempts:e.retryAttempts??(process.env.SEQ_QUEUE_RETRY_ATTEMPTS?Number(process.env.SEQ_QUEUE_RETRY_ATTEMPTS):5)},this.callbacks={},this.results={},this.items=[],this.running=!1}deleteCurrentItem(){let e=this.items.shift();e&&(delete this.callbacks[e],delete this.results[e])}async runWithRetries(e){let t=this.items[0];try{let n=await this.callbacks[t]();this.results[t].resolve(n),this.deleteCurrentItem(),this.run().catch(o=>{console.error("Error during scheduling callback",o)})}catch(n){e<this.config.retryAttempts?(console.error(`Error during executing queue task (attempt: ${e})`,n),await new Promise(o=>setTimeout(o,this.config.retryDelay)),this.runWithRetries(e+1).catch(o=>{console.error("Error during scheduling callback",o)})):(console.error("Reached maximum queue retry attempts",n),this.results[t].reject(n),this.deleteCurrentItem(),this.run().catch(o=>{console.error("Error during scheduling callback",o)}))}}async run(){this.running=!0,this.items.length>0?await this.runWithRetries(1):this.running=!1}add(e){let t=(0,H.v4)();return this.callbacks[t]=e,this.items.push(t),this.running||this.run().catch(n=>{console.error("Error during scheduling callback",n)}),new Promise((n,o)=>this.results[t]={resolve:n,reject:o})}};var E=(n=>(n.RESULTS="results",n.ACTIONS="actions",n.EVENTS="events",n))(E||{});var ne=process.env.AMQP_CONNECTION_TIMEOUT||6e4,C=class{constructor(){this.connection={};this.channel={};this.consumerTag={["actions"]:{},["results"]:{},["events"]:{}};this.opts={};this.queues={["actions"]:[],["results"]:[],["events"]:[]};this.existingConsumers={["actions"]:{},["results"]:{},["events"]:{}};this.seqQueue=new x}getAmqpUri(e){switch(e){case"actions":return process.env.AMQP_URI_ACTIONS;case"events":return process.env.AMQP_URI_EVENTS;case"results":return process.env.AMQP_URI_RESULTS}}checkConnection(e){if(!this.channel[e])throw new Error("Connection not created")}async checkIfQueueExists(e,t){return this.channel[t].checkQueue(e)}async connectToAMQP(e){console.info(`Establishing connection to vhost ${e}`);let t=(0,U.connect)(this.getAmqpUri(e),{connectionOptions:this.opts.connectionOptions});if(t)try{await Promise.race([new Promise((n,o)=>setTimeout(()=>o(),Number(ne))),new Promise(n=>{t.addListener("connect",()=>{console.info(`Rabbit successfully connected to vhost: "${e}"`),n()}),t.addListener("connectFailed",()=>{console.info(`Rabbit failed to connect to vhost: "${e}"`),process.exit(-2)}),t.addListener("disconnect",()=>{console.warn(`Rabbit disconnected from vhost: "${e}"`)}),t.addListener("blocked",()=>{console.warn(`Rabbit connection blocked on vhost: "${e}"`)}),t.addListener("unblocked",()=>{console.info(`Rabbit connection unblocked on vhost: "${e}"`)})})]),this.connection[e]=t}catch{console.error(`Rabbit connection timeout. Could not connect to vhost ${e}. Check connection details`),process.exit(-2)}else console.error(`Connection to vhost ${e} was not created!`),process.exit(-3);return t}async amqpConnect(e,t){let n=await this.connectToAMQP(e);if(n)return new Promise((o,a)=>{let i=n.createChannel({json:!0,setup:async s=>{if(s){this.channel[e]=s,t&&await t();for(let p in this.existingConsumers[e])await this.consume(this.existingConsumers[e][p]);for(let p of this.queues[e])this.sendToQueue(p);this.queues[e]=[],o(n)}a()}});i.addListener("connect",()=>{console.info(`Rabbit successfully connected to channel for vhost: "${e}"`)}),i.addListener("error",()=>{console.error(`Rabbit failed to connect to channel for vhost: "${e}"`)}),i.addListener("close",()=>{console.warn(`Rabbit connection to vhost: "${e}" channel has closed!"`)})});throw new Error("Could not connect to AMQP queue!")}async connectAndInit(e,t){(await this.amqpConnect(e,t)).on("close",()=>{console.error(`Lost AMQP connection with vhost: "${e}". Trying to reconnect in a while.`)})}async connectToVHosts(e){for(let t of e)await this.connectAndInit(t)}async configure(e,t=["events","results","actions"]){this.opts={...e},await this.connectToVHosts(t)}async unsubscribe(e,t,n){if(this.checkConnection(e),!this.consumerTag[e][t]){if(n)return;throw new Error("Cannot unsubscribe from queue with undefined consumer")}await this.channel[e].cancel(this.consumerTag[e][t].consumerTag),delete this.existingConsumers[e][t],delete this.consumerTag[e][t]}sendToQueue({queue:e,vhost:t,data:n,opts:o={}}){this.checkConnection(t);try{return this.channel[t].sendToQueue(e,n,o)}catch(a){throw console.error(`Could not send message. Origin error: ${a.message}. Retrying when reconnected.`),this.queues[t].push({queue:e,vhost:t,data:n,opts:o}),a}}async consume({vhost:e,queue:t,prefetchValue:n=0,ack:o=!1,explicitAck:a=!1,callback:i}){this.checkConnection(e),this.existingConsumers[e][t]={vhost:e,queue:t,prefetchValue:n,ack:o,explicitAck:a,callback:i};let s=async u=>{if(u===null)throw new Error("Received null message, channel closed. Trying to reconnect");let c;try{c=JSON.parse(u.content.toString())}catch{throw new Error("Incorrect incoming AMQP data")}a?await i(c,{ack:()=>this.channel[e].ack(u)}):(await i(c,{}),o&&this.channel[e].ack(u))};if(!await this.checkIfQueueExists(t,e))throw new Error("Queue does not exist!");await this.seqQueue.add(async()=>{await this.channel[e].prefetch(n),this.consumerTag[e][t]=await this.channel[e].consume(t,u=>{s(u).catch(c=>{console.error(`Error during processing message on queue ${t}.`,c)})},{noAck:!o}),await this.channel[e].prefetch(0)})}async assertQueue(e,t,n){this.checkConnection(t),await this.channel[t].assertQueue(e,n)}async deleteQueue(e,t){this.checkConnection(t),await this.channel[t].deleteQueue(e)}},F=new C;var T=class{constructor(){this.amqp=F}static parseQueue(e,t){let n=e;for(let[o,a]of Object.entries(t))n=n.replace(`{${o}}`,a);return n}async init(e,t){await this.amqp.configure(e,t)}async consume({vhost:e="events",queue:t,queueParams:n={},prefetchValue:o=0,ack:a=!1,explicitAck:i=!1,callback:s,queueOptions:p={}}){let u=T.parseQueue(t,n);await this.amqp.assertQueue(u,e,p),await this.amqp.consume({vhost:e,queue:u,prefetchValue:o,ack:a,explicitAck:i,callback:s??(()=>Promise.resolve())})}async publish({queue:e,queueParams:t={},event:n,vhost:o="events",opts:a={},queueOptions:i={}}){let s=T.parseQueue(e,t);await this.amqp.assertQueue(s,o,i),this.amqp.sendToQueue({queue:s,vhost:o,data:Buffer.from(JSON.stringify(n)),opts:a})}async unsubscribe({queue:e,queueParams:t={},vhost:n="events",allowNotSubscribed:o=!1}){let a=T.parseQueue(e,t);await this.amqp.unsubscribe(n,a,o)}async deleteQueue({queue:e,queueParams:t={},vhost:n="events"}){let o=T.parseQueue(e,t);await this.amqp.deleteQueue(o,n)}async registerConsumer({queue:e,consumer:t,vhost:n="events",prefetchValue:o=0,ack:a=!1}){await this.consume({queue:e,vhost:n,prefetchValue:o,ack:a,callback:async i=>{let s=await t(i);for(let p of s)await this.publish(p)}})}},y=new T;var b=N(require("lodash/get"));var S={};D(S,{applyInputMapping:()=>h,composition:()=>se,condition:()=>ae,flowTemplate:()=>q,parallel:()=>pe,param:()=>ie,queue:()=>M});var O=N(require("lodash/get"));function K(r){return r.type==="event"}function $(r){return r.type==="param"}function re(r){return Array.isArray(r)}function oe(r){return r.type==="condition"}function L(r){return r.type==="composition"}function f(r,e,t){if(r.length===0)return t;let[n,...o]=r,a=f(o,e,t);if(L(n))return f(n.restFlow,e,a);if(oe(n)){let{queue:i,predicate:s,elseFlow:p,thenFlow:u}=n;return[{vhost:i.vhost,queue:i.queue,errorQueue:i.errorQueue,inputMapping:i.inputMapping,outputMapping:i.outputMapping,errorMapping:i.errorMapping,queueParams:i.queueParams,predicate:s,nextFlow:f(u,e,a),elseFlow:f(p??[],e,a),queueOptions:i.queueOptions}]}if(K(n)){let{queue:i,vhost:s,errorQueue:p,inputMapping:u,outputMapping:c,errorMapping:l,queueParams:g,queueOptions:m}=n;return[{queue:i,vhost:s,inputMapping:u,outputMapping:c,errorMapping:l,nextFlow:a,errorQueue:p,queueParams:g,queueOptions:m}]}if($(n)){let i=e[n.name];return typeof i=="string"?[{queue:i,inputMapping:{},outputMapping:{},errorMapping:{},nextFlow:a}]:[{queue:i.queue,vhost:i.vhost,inputMapping:i.inputMapping,outputMapping:i.outputMapping,errorMapping:i.errorMapping,errorQueue:i.errorQueue,queueParams:i.queueParams,nextFlow:a}]}if(re(n)){let i=f(o,e,t);return n.map(s=>f(s,e,i)).reduce((s,p)=>p?s.concat(p):s,[])}}function h(r,e={}){return Object.keys(e).reduce((t,n)=>{let o=e[n];return Array.isArray(o)?{...t,[n]:o.map(a=>(0,O.default)(r,a))}:{...t,[n]:(0,O.default)(r,o)}},{})}function q(r,...e){let t=r,n=e;L(r)&&(t=r.restFlow[0],n=[...r.restFlow.slice(1),...n]);let o=a=>({vhost:t.vhost,initQueue:t.queue,inputData:h(a.flowVariables,t.inputMapping),flowVariables:a.flowVariables,errorVariables:a.errorVariables,outputMapping:t.outputMapping,errorMapping:t.errorMapping,nextFlow:f(n,a.params),errorQueue:t.errorQueue,queueOptions:t.queueOptions});return o.restFlow=[r,...e],o}function M(r,e){return{type:"event",queue:r,vhost:e.vhost,inputMapping:e.inputMapping,outputMapping:e.outputMapping,errorMapping:e.errorMapping,queueParams:e.queueParams,queueOptions:e.queueOptions,onError(t){return{...this,errorQueue:t}}}}function ie(r){return{type:"param",name:r}}function ae(r){return{type:"condition",...r}}function se(r,...e){let t=r?.restFlow??[];for(let n of e)t=[...t,...n.restFlow];return{type:"composition",restFlow:t}}function pe(...r){function e(o){return Array.isArray(o)&&(K(o[0])||$(o[0]))}function t(o){return Array.isArray(o)&&!e(o)}return r.reduce((o,a)=>e(a)?o.concat([a]):t(a)?o.concat([a]):o.concat([[a]]),[])}var w=require("lodash"),ue={passFlowVariables:!1,passErrorVariables:!0};function _(r,e,t){return e?Object.keys(e).reduce((n,o)=>{let a=e[o];if(le(a)){let i=a["$push"],s=n[i]??[];return s instanceof Array?{...n,[i]:[...s,(0,b.default)(t,o)]}:{...n}}else if(ce(a)){let i=a["$remove"],s=n[i]??[];return s instanceof Array?{...n,[i]:s.filter(p=>!(0,w.isEqual)(p,(0,b.default)(t,o)))}:{...n}}else{if(A(a))return{...n};if(Array.isArray(a)){let i=a.reduce((s,p)=>({...s,[p]:(0,b.default)(t,o)}),{});return{...n,...i}}return{...n,[a]:(0,b.default)(t,o)}}},r):r}function A(r){return(0,w.isObject)(r)&&!(r instanceof Array)}function le(r){return A(r)&&!!r["$push"]}function ce(r){return A(r)&&!!r["$remove"]}function W(r,e,t){return(r??[]).map(n=>{let o={inputData:h(e,n.inputMapping??{}),outputMapping:n.outputMapping,errorMapping:n.errorMapping,nextFlow:n.nextFlow,errorQueue:n.errorQueue,elseFlow:n.elseFlow,predicate:n.predicate,flowVariables:e,errorVariables:t};return{vhost:n.vhost,queue:n.queue,queueParams:h(e,n.queueParams??{}),event:o,queueOptions:n.queueOptions}})}async function k(r,e,t,n){try{let o=t.inputData,a=await Promise.resolve(e(o,{ack:n,publish:me(t)}))??{},i=_(t.flowVariables??{},t.outputMapping,a),s=_(t.errorVariables??{},t.errorMapping,a);return t.predicate&&!(0,b.default)(i,t.predicate)?W(t.elseFlow??[],i,s):W(t.nextFlow??[],i,s)}catch(o){return console.error(`Error in consumer "${r}"`),console.error(o),[{queue:t.errorQueue??"Error/General",event:{inputData:{queue:r,error:{message:o?.message,stack:o?.stack,data:o.data},event:t}}}]}}function me(r){return async({event:e,options:t=ue,queueParams:n,vhost:o})=>{t?.passErrorVariables&&(e.errorVariables=(0,w.isObject)(e.errorVariables)?Object.assign(r.errorVariables??{},e.errorVariables):r.errorVariables??{}),t?.passFlowVariables&&(e.flowVariables=(0,w.isObject)(e.flowVariables)?Object.assign(r.flowVariables??{},e.flowVariables):r.flowVariables??{}),await y.publish({vhost:o,queue:e.initQueue,queueParams:n??{},event:e})}}async function V({queue:r,queueParams:e,prefetchValue:t=0,explicitAck:n=!1,vhost:o,callback:a,queueOptions:i}){await y.consume({queue:r,queueParams:e,prefetchValue:t,ack:!0,vhost:o,explicitAck:n,queueOptions:i,callback:async(s,p)=>{console.info(`Consuming queue ${r}`);let u=await k(r,a,s,p?.ack);for(let c of u)await y.publish(c)}})}var Q={};D(Q,{createActionExecutionData:()=>de,createCodeContext:()=>Y});var B=r=>({startTime:r.startTime,finishTime:r.finishTime,status:r.status,result:r?.twiddlebugResult?.result,errorCode:r?.twiddlebugResult?.errorCode,output:`${r?.twiddlebugResult?.result?JSON.stringify(r.twiddlebugResult.result)+`
`:""}${r?.twiddlebugResult?.stdout?r.twiddlebugResult.stdout+`
`:""}${r?.twiddlebugResult?.stderr?r.twiddlebugResult.stderr+`
`:""}`}),Y=({actions:r,actionResults:e=[],pipelineExecutionId:t,pipelineRevision:n,trigger:o,triggerPayload:a,configuration:i,inputs:s,configurations:p})=>{let u=r.reduce((c,l)=>{let g=e.filter(d=>d.actionId===l.uuid).pop(),m=g?B(g):{};return{[l.codeId]:{id:l.codeId,name:l.name,mandatory:l.mandatory,retries:l.retries,timeout:l.timeout,plugin:{name:l.usedPlugin.name,version:l.usedPlugin.version},...m,executions:e.filter(d=>d.actionId===l.uuid).map(B)},...c}},{});return{kaholo:{actions:u,pipeline:{id:n?.pipeline.id,name:n?.pipeline.name,configurations:p},execution:{id:t,inputs:s,agent:{name:n?.agent?.name,attributes:n?.agent?.attributes},trigger:{message:o,payload:a},configuration:i}},actions:u}},de=({actionExecutionId:r,pipelineExecutionId:e,actionId:t,pipelineId:n,agentKey:o,pipelineRevision:a,actionRevision:i,actionResults:s,trigger:p,triggerPayload:u,configuration:c,inputs:l,configurations:g})=>({actionExecutionId:r,pipelineExecutionId:e,actionId:t,pipelineId:n,agentKey:o,condition:i.condition,preHook:i.preHook,postHook:i.postHook,retries:i.retries??0,timeout:i.timeout,usedPlugin:i.usedPlugin,method:i.method,pipelineRevision:a,pluginAccount:i.pluginAccount,params:i.params.reduce((m,d)=>({...m,[d.name]:{...d,resolved:!(d.code||d.type==="vault")}}),{}),pluginSettings:i.pluginSettings.reduce((m,d)=>({...m,[d.name]:{...d,resolved:d.type!=="vault"}}),{}),codeContext:Y({actions:a.actions,actionResults:s,pipelineExecutionId:e,pipelineRevision:a,trigger:p,triggerPayload:u,configuration:c,inputs:l,configurations:g})});var J=require("uuid");var j=parseInt(process.env.RPC_REQUEST_TIMEOUT)||2e4,P=class extends Error{constructor({message:t,data:n}){super(t);Error.captureStackTrace&&Error.captureStackTrace(this,P),this.data=n,this.error=n.responseData?.error}};async function Te(r,e){await y.unsubscribe({vhost:r,queue:"RPC/Response/{requestId}",queueParams:{requestId:e}}),await y.deleteQueue({vhost:r,queue:"RPC/Response/{requestId}",queueParams:{requestId:e}})}async function R({requestVhost:r="events",responseVhost:e="events",requestQueue:t,queueParams:n,requestData:o,retries:a=0}){let i=(0,J.v4)(),s={expires:j,durable:!1},u=q(M(t,{vhost:r,inputMapping:{requestId:"requestId",requestData:"requestData"},outputMapping:{ok:"ok",responseData:"responseData"}}),M("RPC/Response/{requestId}",{vhost:e,queueParams:{requestId:"requestId"},inputMapping:{ok:"ok",responseData:"responseData"},queueOptions:s}))({flowVariables:{requestData:o,requestId:i},params:{}});return await y.publish({vhost:r,queue:t,queueParams:n,event:u}),new Promise((c,l)=>{let g=setTimeout(()=>{a?(console.info(`Retrying RPC request because of timeout (${a-1} left)} ${t}`),R({requestVhost:r,responseVhost:e,requestQueue:t,queueParams:n,requestData:o,retries:a-1}).then(c).catch(l)):l(new Error(`Timeout reached waiting for RPC response for ${t} request`))},j);V({vhost:e,queue:"RPC/Response/{requestId}",queueParams:{requestId:i},queueOptions:s,callback:m=>(clearTimeout(g),setTimeout(()=>{Te(e,i).catch(d=>console.error("Error during RPC cleanup",d))},1e3),m.ok?c(m.responseData):a?(console.info(`Retrying RPC request because of error (${a-1} left) "${t}"`,m.responseData?.error),R({requestVhost:r,responseVhost:e,requestQueue:t,queueParams:n,requestData:o,retries:a-1}).then(c).catch(l)):l(new P({message:`Error in RPC response for ${t} request`,data:m})),{})}).catch(m=>{l(m),console.error("Error during RPC response consumer registration",m)})})}0&&(module.exports={AmqpSdk,EventsWorker,VHOST,amqpSdk,eventsWorker,executionDataHelper,flowConsumer,flowHelpers,flowInterpreter,rpcRequest});
